<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Database Migration Test</title>
  <style>
    body { font-family: monospace; padding: 20px; max-width: 1200px; margin: 0 auto; }
    .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
    button { padding: 8px 16px; margin: 5px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; }
    button:hover { background: #45a049; }
    button.danger { background: #f44336; }
    button.danger:hover { background: #da190b; }
    pre { background: #f5f5f5; padding: 10px; border-radius: 3px; overflow-x: auto; }
    .success { color: green; font-weight: bold; }
    .error { color: red; font-weight: bold; }
    .info { color: blue; }
    .warning { color: orange; }
    table { width: 100%; border-collapse: collapse; margin: 10px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f2f2f2; }
  </style>
</head>
<body>
  <h1>Database Migration Test</h1>
  
  <div class="section">
    <h3>1. Current Databases</h3>
    <button onclick="listDatabases()">List All Databases</button>
    <button onclick="checkMigrationStatus()">Check Migration Status</button>
    <div id="databaseList"></div>
  </div>

  <div class="section">
    <h3>2. Create Old Format Databases (for testing)</h3>
    <button onclick="createOldDatabases()">Create Old DBs</button>
    <button class="danger" onclick="deleteAllDatabases()">Delete All DBs</button>
    <pre id="createResult"></pre>
  </div>

  <div class="section">
    <h3>3. Run Migration</h3>
    <button onclick="runMigration()">Run Database Migration</button>
    <button onclick="clearMigrationFlag()">Clear Migration Flag</button>
    <pre id="migrationResult"></pre>
  </div>

  <div class="section">
    <h3>4. Verify Migration</h3>
    <button onclick="verifyMigration()">Verify All Databases</button>
    <div id="verificationResult"></div>
  </div>

  <div class="section">
    <h3>5. Test Data Operations</h3>
    <button onclick="testDataOperations()">Test Read/Write</button>
    <pre id="operationResult"></pre>
  </div>

  <script type="module">
    import { dbMigrator } from './js/utils/databaseMigration.js';
    import { chainManager } from './js/config/chainConfig.js';
    
    window.dbMigrator = dbMigrator;
    window.chainManager = chainManager;
    
    // 1. List all databases
    window.listDatabases = async function() {
      const resultDiv = document.getElementById('databaseList');
      
      try {
        let databases = [];
        
        if (indexedDB.databases) {
          databases = await indexedDB.databases();
        } else {
          // Fallback - try to open known databases
          const knownDbs = [
            'DB_Cointool', 'DB_Xenft', 'DB-Xen-Stake', 'DB-Xenft-Stake',
            'ETH_DB_Cointool', 'ETH_DB_Xenft', 'ETH_DB_XenStake', 'ETH_DB_XenftStake',
            'BASE_DB_Cointool', 'BASE_DB_Xenft', 'BASE_DB_XenStake', 'BASE_DB_XenftStake'
          ];
          
          for (const name of knownDbs) {
            try {
              const db = await openDb(name);
              if (db) {
                databases.push({ name, version: db.version });
                db.close();
              }
            } catch (e) {}
          }
        }
        
        if (databases.length === 0) {
          resultDiv.innerHTML = '<p class="info">No databases found</p>';
          return;
        }
        
        // Create table
        let html = '<table><thead><tr><th>Database Name</th><th>Version</th><th>Type</th></tr></thead><tbody>';
        
        databases.forEach(db => {
          let type = 'Unknown';
          if (db.name.startsWith('ETH_')) type = 'Ethereum (New)';
          else if (db.name.startsWith('BASE_')) type = 'Base';
          else if (db.name.startsWith('DB_') || db.name.startsWith('DB-')) type = 'Old Format';
          
          html += `<tr>
            <td>${db.name}</td>
            <td>${db.version}</td>
            <td>${type}</td>
          </tr>`;
        });
        
        html += '</tbody></table>';
        resultDiv.innerHTML = html;
        
      } catch (error) {
        resultDiv.innerHTML = `<p class="error">Error: ${error.message}</p>`;
      }
    };
    
    // Check migration status
    window.checkMigrationStatus = function() {
      const status = localStorage.getItem('dbMigrationCompleted');
      const migrationFlag = localStorage.getItem('migrationCompleted');
      
      const result = {
        databaseMigration: status || 'Not completed',
        localStorageMigration: migrationFlag || 'Not completed'
      };
      
      document.getElementById('databaseList').innerHTML = 
        `<pre>${JSON.stringify(result, null, 2)}</pre>`;
    };
    
    // 2. Create old format databases
    window.createOldDatabases = async function() {
      const oldDbs = [
        { name: 'DB_Cointool', version: 3, stores: ['mints', 'scanState', 'actionsCache'] },
        { name: 'DB_Xenft', version: 1, stores: ['mints', 'scanState'] },
        { name: 'DB-Xen-Stake', version: 1, stores: ['stakes', 'scanState'] },
        { name: 'DB-Xenft-Stake', version: 1, stores: ['stakes', 'scanState'] }
      ];
      
      const results = [];
      
      for (const dbConfig of oldDbs) {
        try {
          const db = await new Promise((resolve, reject) => {
            const request = indexedDB.open(dbConfig.name, dbConfig.version);
            
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              
              dbConfig.stores.forEach(storeName => {
                if (!db.objectStoreNames.contains(storeName)) {
                  let keyPath = 'id';
                  if (storeName === 'mints') keyPath = 'ID';
                  if (storeName === 'scanState') keyPath = 'address';
                  if (storeName === 'actionsCache') keyPath = 'address';
                  
                  db.createObjectStore(storeName, { keyPath });
                }
              });
            };
            
            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject(event.target.error);
          });
          
          // Add some test data
          if (dbConfig.stores.includes('mints')) {
            const tx = db.transaction('mints', 'readwrite');
            const store = tx.objectStore('mints');
            store.put({ ID: 'test1', Address: '0x123...', Amount: 1000 });
          }
          
          db.close();
          results.push(`✅ Created ${dbConfig.name}`);
        } catch (error) {
          results.push(`❌ Failed to create ${dbConfig.name}: ${error.message}`);
        }
      }
      
      document.getElementById('createResult').textContent = results.join('\\n');
    };
    
    // Delete all databases
    window.deleteAllDatabases = async function() {
      if (!confirm('This will delete ALL databases. Are you sure?')) return;
      
      const allDbs = [
        'DB_Cointool', 'DB_Xenft', 'DB-Xen-Stake', 'DB-Xenft-Stake',
        'ETH_DB_Cointool', 'ETH_DB_Xenft', 'ETH_DB_XenStake', 'ETH_DB_XenftStake',
        'BASE_DB_Cointool', 'BASE_DB_Xenft', 'BASE_DB_XenStake', 'BASE_DB_XenftStake'
      ];
      
      const results = [];
      
      for (const name of allDbs) {
        try {
          await new Promise((resolve) => {
            const request = indexedDB.deleteDatabase(name);
            request.onsuccess = () => resolve();
            request.onerror = () => resolve();
            request.onblocked = () => resolve();
          });
          results.push(`Deleted ${name}`);
        } catch (e) {}
      }
      
      document.getElementById('createResult').textContent = 
        results.length > 0 ? results.join('\\n') : 'No databases to delete';
      
      // Refresh list
      listDatabases();
    };
    
    // 3. Run migration
    window.runMigration = async function() {
      try {
        const results = await dbMigrator.migrate();
        document.getElementById('migrationResult').textContent = 
          results.length > 0 ? results.join('\\n') : 'Migration completed (no changes needed)';
        
        // Refresh database list
        listDatabases();
      } catch (error) {
        document.getElementById('migrationResult').textContent = 
          `Error: ${error.message}`;
      }
    };
    
    // Clear migration flag
    window.clearMigrationFlag = function() {
      localStorage.removeItem('dbMigrationCompleted');
      localStorage.removeItem('migrationCompleted');
      document.getElementById('migrationResult').textContent = 
        'Migration flags cleared. Migration will run on next load.';
    };
    
    // 4. Verify migration
    window.verifyMigration = async function() {
      const resultDiv = document.getElementById('verificationResult');
      const checks = [];
      
      // Check Ethereum databases
      const ethDbs = ['ETH_DB_Cointool', 'ETH_DB_Xenft', 'ETH_DB_XenStake', 'ETH_DB_XenftStake'];
      for (const name of ethDbs) {
        try {
          const db = await openDb(name);
          if (db) {
            checks.push(`✅ ${name} exists (v${db.version})`);
            db.close();
          } else {
            checks.push(`❌ ${name} not found`);
          }
        } catch (e) {
          checks.push(`❌ ${name} error: ${e.message}`);
        }
      }
      
      // Check Base databases
      const baseDbs = ['BASE_DB_Cointool', 'BASE_DB_Xenft', 'BASE_DB_XenStake', 'BASE_DB_XenftStake'];
      for (const name of baseDbs) {
        try {
          const db = await openDb(name);
          if (db) {
            checks.push(`✅ ${name} exists (v${db.version})`);
            db.close();
          } else {
            checks.push(`❌ ${name} not found`);
          }
        } catch (e) {
          checks.push(`❌ ${name} error: ${e.message}`);
        }
      }
      
      // Check old databases are gone
      const oldDbs = ['DB_Cointool', 'DB_Xenft', 'DB-Xen-Stake', 'DB-Xenft-Stake'];
      for (const name of oldDbs) {
        try {
          const db = await openDb(name);
          if (db) {
            checks.push(`⚠️ Old database ${name} still exists!`);
            db.close();
          } else {
            checks.push(`✅ Old database ${name} removed`);
          }
        } catch (e) {
          checks.push(`✅ Old database ${name} removed`);
        }
      }
      
      resultDiv.innerHTML = `<pre>${checks.join('\\n')}</pre>`;
    };
    
    // 5. Test data operations
    window.testDataOperations = async function() {
      const results = [];
      
      try {
        // Test Ethereum database
        chainManager.setChain('ETHEREUM');
        const ethDbName = chainManager.getDatabaseName('cointool');
        results.push(`Ethereum DB: ${ethDbName}`);
        
        const ethDb = await openDb(ethDbName);
        if (ethDb) {
          // Try to read data
          const tx = ethDb.transaction('mints', 'readonly');
          const store = tx.objectStore('mints');
          const data = await new Promise((resolve) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
          });
          results.push(`  - Found ${data.length} mints`);
          ethDb.close();
        }
        
        // Test Base database
        chainManager.setChain('BASE');
        const baseDbName = chainManager.getDatabaseName('cointool');
        results.push(`Base DB: ${baseDbName}`);
        
        const baseDb = await openDb(baseDbName);
        if (baseDb) {
          // Try to write and read data
          const tx = baseDb.transaction('mints', 'readwrite');
          const store = tx.objectStore('mints');
          store.put({ ID: 'base_test', Address: '0xBASE...', Amount: 500 });
          
          await new Promise((resolve) => {
            tx.oncomplete = resolve;
          });
          
          results.push(`  - Successfully wrote test data`);
          baseDb.close();
        }
        
      } catch (error) {
        results.push(`Error: ${error.message}`);
      }
      
      document.getElementById('operationResult').textContent = results.join('\\n');
    };
    
    // Helper function to open database
    async function openDb(name) {
      return new Promise((resolve) => {
        const request = indexedDB.open(name);
        request.onsuccess = (event) => resolve(event.target.result);
        request.onerror = () => resolve(null);
      });
    }
    
    // Auto-load on start
    document.addEventListener('DOMContentLoaded', () => {
      listDatabases();
      checkMigrationStatus();
    });
  </script>
</body>
</html>