<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Recovery and Diagnostic Tool</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .alert {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .alert-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
        }
        .alert-info {
            background: #d1ecf1;
            border: 1px solid #17a2b8;
            color: #0c5460;
        }
        .alert-success {
            background: #d4edda;
            border: 1px solid #28a745;
            color: #155724;
        }
        .alert-danger {
            background: #f8d7da;
            border: 1px solid #dc3545;
            color: #721c24;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button.success {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        button.warning {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        button.danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .database-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .database-card h3 {
            margin-top: 0;
            color: #495057;
        }
        .store-info {
            margin-left: 20px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            margin-top: 10px;
        }
        .data-preview {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .status-log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
        }
        .recovery-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .recovery-card {
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
        }
        .recovery-card h4 {
            margin-top: 0;
            color: #667eea;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-card {
            background: white;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-card h3 {
            margin: 0;
            color: #667eea;
            font-size: 24px;
        }
        .stat-card p {
            margin: 5px 0 0 0;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Database Recovery and Diagnostic Tool</h1>
        
        <div class="alert alert-warning">
            ‚ö†Ô∏è This tool will help diagnose and recover your missing database data
        </div>

        <div class="section">
            <h2>üìä Quick Diagnostics</h2>
            <div class="stats-grid" id="statsGrid">
                <!-- Stats will be populated here -->
            </div>
            
            <button onclick="runFullDiagnostics()" class="success">
                üîç Run Full Diagnostics
            </button>
            
            <button onclick="checkAllDatabases()">
                üìÅ Check All Databases
            </button>
            
            <button onclick="findLegacyDatabases()" class="warning">
                üîé Find Legacy Databases
            </button>
            
            <button onclick="checkBackups()">
                üíæ Check Available Backups
            </button>
        </div>

        <div class="section">
            <h2>üóÑÔ∏è Database Status</h2>
            <div id="databaseList"></div>
        </div>

        <div class="section">
            <h2>üöë Recovery Options</h2>
            <div class="recovery-options" id="recoveryOptions"></div>
        </div>

        <div class="section">
            <h2>üõ†Ô∏è Advanced Recovery</h2>
            
            <button onclick="resetMigrationFlag()" class="warning">
                üîÑ Reset Migration Flag (Allow Re-migration)
            </button>
            
            <button onclick="attemptDataRecovery()" class="success">
                üîÆ Attempt Smart Recovery
            </button>
            
            <button onclick="mergeDatabases()" class="warning">
                üîÄ Merge Duplicate Databases
            </button>
            
            <button onclick="exportAllData()">
                üì§ Export All Data to JSON
            </button>
            
            <button onclick="importDataFromJSON()" class="warning">
                üì• Import Data from JSON
            </button>
        </div>

        <div class="section">
            <h2>üìù Status Log</h2>
            <div id="statusLog" class="status-log"></div>
        </div>
    </div>

    <script type="module">
        import { superSafeMigrator } from './js/utils/databaseMigrationSuperSafe.js';
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('statusLog');
            const entry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<span style="color: ${type === 'error' ? 'red' : type === 'success' ? 'green' : '#666'};">[${timestamp}] ${message}</span>`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        async function updateStats() {
            const statsGrid = document.getElementById('statsGrid');
            
            // Count databases
            const allDbs = await getAllDatabaseNames();
            const legacyDbs = allDbs.filter(name => !name.includes('ETH_') && !name.includes('BASE_'));
            const ethDbs = allDbs.filter(name => name.includes('ETH_'));
            const baseDbs = allDbs.filter(name => name.includes('BASE_'));
            
            // Count total records
            let totalRecords = 0;
            for (const dbName of allDbs) {
                const count = await countDatabaseRecords(dbName);
                totalRecords += count;
            }
            
            // Check migration status
            const migrationStatus = localStorage.getItem('dbMigrationCompleted') || 'Not migrated';
            
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>${allDbs.length}</h3>
                    <p>Total Databases</p>
                </div>
                <div class="stat-card">
                    <h3>${legacyDbs.length}</h3>
                    <p>Legacy Databases</p>
                </div>
                <div class="stat-card">
                    <h3>${ethDbs.length}</h3>
                    <p>Ethereum DBs</p>
                </div>
                <div class="stat-card">
                    <h3>${baseDbs.length}</h3>
                    <p>Base DBs</p>
                </div>
                <div class="stat-card">
                    <h3>${totalRecords}</h3>
                    <p>Total Records</p>
                </div>
                <div class="stat-card">
                    <h3>${migrationStatus.split('_')[0]}</h3>
                    <p>Migration Version</p>
                </div>
            `;
        }
        
        async function getAllDatabaseNames() {
            const databases = new Set();
            
            // Known database names
            const knownDbs = [
                'DB_Cointool', 'DB_Xenft', 'DB_XenStake', 'DB_XenftStake',
                'ETH_DB_Cointool', 'ETH_DB_Xenft', 'ETH_DB_XenStake', 'ETH_DB_XenftStake',
                'BASE_DB_Cointool', 'BASE_DB_Xenft', 'BASE_DB_XenStake', 'BASE_DB_XenftStake'
            ];
            
            // Check which ones exist
            const existing = [];
            for (const name of knownDbs) {
                if (await databaseExists(name)) {
                    existing.push(name);
                }
            }
            
            return existing;
        }
        
        async function databaseExists(name) {
            return new Promise((resolve) => {
                const request = indexedDB.open(name);
                let exists = false;
                
                request.onsuccess = (event) => {
                    exists = true;
                    event.target.result.close();
                    resolve(true);
                };
                
                request.onerror = () => resolve(false);
                
                request.onupgradeneeded = (event) => {
                    if (event.oldVersion === 0) {
                        exists = false;
                        event.target.transaction.abort();
                    } else {
                        exists = true;
                    }
                };
                
                setTimeout(() => resolve(exists), 100);
            });
        }
        
        async function countDatabaseRecords(dbName) {
            try {
                const db = await openDatabase(dbName);
                if (!db) return 0;
                
                let total = 0;
                for (const storeName of db.objectStoreNames) {
                    const count = await getStoreCount(db, storeName);
                    total += count;
                }
                
                db.close();
                return total;
            } catch {
                return 0;
            }
        }
        
        async function openDatabase(name) {
            return new Promise((resolve) => {
                const request = indexedDB.open(name);
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = () => resolve(null);
                request.onupgradeneeded = (event) => {
                    if (event.oldVersion === 0) {
                        event.target.transaction.abort();
                        resolve(null);
                    }
                };
            });
        }
        
        async function getStoreCount(db, storeName) {
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.count();
                    request.onsuccess = () => resolve(request.result || 0);
                    request.onerror = () => resolve(0);
                } catch {
                    resolve(0);
                }
            });
        }
        
        async function getStoreData(db, storeName, limit = 5) {
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.openCursor();
                    const data = [];
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor && data.length < limit) {
                            data.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(data);
                        }
                    };
                    
                    request.onerror = () => resolve([]);
                } catch {
                    resolve([]);
                }
            });
        }
        
        window.runFullDiagnostics = async function() {
            log('Starting full diagnostics...', 'info');
            
            const databases = await getAllDatabaseNames();
            log(`Found ${databases.length} databases`, 'success');
            
            const databaseList = document.getElementById('databaseList');
            databaseList.innerHTML = '';
            
            for (const dbName of databases) {
                const card = document.createElement('div');
                card.className = 'database-card';
                
                const db = await openDatabase(dbName);
                if (db) {
                    let dbInfo = `<h3>${dbName} (v${db.version})</h3>`;
                    let totalRecords = 0;
                    
                    for (const storeName of db.objectStoreNames) {
                        const count = await getStoreCount(db, storeName);
                        totalRecords += count;
                        
                        const sampleData = await getStoreData(db, storeName, 2);
                        
                        dbInfo += `<div class="store-info">`;
                        dbInfo += `<strong>${storeName}:</strong> ${count} records`;
                        
                        if (sampleData.length > 0) {
                            dbInfo += `<div class="data-preview">Sample: ${JSON.stringify(sampleData[0], null, 2).substring(0, 200)}...</div>`;
                        }
                        
                        dbInfo += `</div>`;
                    }
                    
                    dbInfo += `<p><strong>Total Records:</strong> ${totalRecords}</p>`;
                    
                    // Check if this is a legacy database
                    if (!dbName.includes('ETH_') && !dbName.includes('BASE_')) {
                        dbInfo += `<div class="alert alert-warning">‚ö†Ô∏è This is a legacy database that should be migrated</div>`;
                    }
                    
                    card.innerHTML = dbInfo;
                    databaseList.appendChild(card);
                    
                    db.close();
                }
            }
            
            log('Diagnostics complete', 'success');
            await updateStats();
            await checkRecoveryOptions();
        };
        
        window.checkAllDatabases = async function() {
            await runFullDiagnostics();
        };
        
        window.findLegacyDatabases = async function() {
            log('Searching for legacy databases...', 'info');
            
            const legacyNames = [
                'DB_Cointool', 'DB_Xenft', 'DB_XenStake', 'DB_XenftStake'
            ];
            
            const found = [];
            for (const name of legacyNames) {
                if (await databaseExists(name)) {
                    const count = await countDatabaseRecords(name);
                    found.push({ name, count });
                    log(`Found legacy database: ${name} (${count} records)`, 'success');
                }
            }
            
            if (found.length === 0) {
                log('No legacy databases found', 'warning');
            } else {
                log(`Found ${found.length} legacy databases with data`, 'success');
                
                // Show recovery option
                const recoveryDiv = document.getElementById('recoveryOptions');
                recoveryDiv.innerHTML = `
                    <div class="recovery-card">
                        <h4>Legacy Databases Found</h4>
                        <p>Found ${found.length} legacy databases that can be migrated:</p>
                        <ul>
                            ${found.map(db => `<li>${db.name}: ${db.count} records</li>`).join('')}
                        </ul>
                        <button onclick="migrateLegacyDatabases()" class="success">
                            Migrate Legacy Databases
                        </button>
                    </div>
                `;
            }
        };
        
        window.checkBackups = async function() {
            log('Checking for backups...', 'info');
            
            const backups = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('db_backup_')) {
                    const timestamp = key.replace('db_backup_', '').replace(/_chunks$/, '').replace(/_\d+$/, '');
                    if (!isNaN(timestamp)) {
                        backups.push({
                            key: key.replace(/_chunks$/, '').replace(/_\d+$/, ''),
                            timestamp: parseInt(timestamp),
                            date: new Date(parseInt(timestamp)).toLocaleString()
                        });
                    }
                }
            }
            
            backups.sort((a, b) => b.timestamp - a.timestamp);
            
            if (backups.length > 0) {
                log(`Found ${backups.length} backup(s)`, 'success');
                
                const recoveryDiv = document.getElementById('recoveryOptions');
                recoveryDiv.innerHTML += `
                    <div class="recovery-card">
                        <h4>Backups Available</h4>
                        <p>Found ${backups.length} backup(s):</p>
                        <ul>
                            ${backups.map(b => `<li>${b.date} <button onclick="restoreBackup('${b.key}')">Restore</button></li>`).join('')}
                        </ul>
                    </div>
                `;
            } else {
                log('No backups found', 'warning');
            }
        };
        
        async function checkRecoveryOptions() {
            const recoveryDiv = document.getElementById('recoveryOptions');
            recoveryDiv.innerHTML = '';
            
            // Check for various recovery scenarios
            const databases = await getAllDatabaseNames();
            const legacyDbs = databases.filter(name => !name.includes('ETH_') && !name.includes('BASE_'));
            const ethDbs = databases.filter(name => name.includes('ETH_'));
            
            // Check for data in legacy databases
            let legacyRecords = 0;
            for (const db of legacyDbs) {
                legacyRecords += await countDatabaseRecords(db);
            }
            
            // Check for data in ETH databases
            let ethRecords = 0;
            for (const db of ethDbs) {
                ethRecords += await countDatabaseRecords(db);
            }
            
            if (legacyRecords > 0) {
                recoveryDiv.innerHTML += `
                    <div class="recovery-card">
                        <h4>üîÑ Legacy Data Found</h4>
                        <p>${legacyRecords} records found in legacy databases</p>
                        <button onclick="migrateLegacyDatabases()" class="success">
                            Migrate to Chain-Specific DBs
                        </button>
                    </div>
                `;
            }
            
            if (ethRecords === 0 && legacyRecords === 0) {
                recoveryDiv.innerHTML += `
                    <div class="recovery-card">
                        <h4>‚ö†Ô∏è No Data Found</h4>
                        <p>No data found in any database</p>
                        <button onclick="checkBackups()" class="warning">
                            Check for Backups
                        </button>
                    </div>
                `;
            }
            
            // Always show export/import options
            recoveryDiv.innerHTML += `
                <div class="recovery-card">
                    <h4>üì§ Export/Import</h4>
                    <p>Backup or restore your data</p>
                    <button onclick="exportAllData()">Export All Data</button>
                    <button onclick="document.getElementById('importFile').click()" class="warning">Import from File</button>
                    <input type="file" id="importFile" style="display:none" accept=".json" onchange="handleImportFile(event)">
                </div>
            `;
        }
        
        window.resetMigrationFlag = function() {
            if (confirm('This will reset the migration flag and allow re-migration. Continue?')) {
                localStorage.removeItem('dbMigrationCompleted');
                localStorage.removeItem('lastSuccessfulMigration');
                localStorage.removeItem('migrationDuration');
                log('Migration flag reset - refresh the page to trigger migration', 'success');
            }
        };
        
        window.migrateLegacyDatabases = async function() {
            log('Starting manual migration of legacy databases...', 'info');
            
            // Reset flag first
            localStorage.removeItem('dbMigrationCompleted');
            
            try {
                const result = await superSafeMigrator.migrate();
                
                if (result.success) {
                    log('Migration completed successfully!', 'success');
                    if (result.results) {
                        for (const msg of result.results) {
                            log(msg, msg.includes('‚úÖ') ? 'success' : 'info');
                        }
                    }
                } else {
                    log('Migration failed: ' + result.error, 'error');
                }
                
                // Refresh diagnostics
                await runFullDiagnostics();
                
            } catch (error) {
                log('Migration error: ' + error.message, 'error');
            }
        };
        
        window.attemptDataRecovery = async function() {
            log('Attempting smart data recovery...', 'info');
            
            // Look for any databases with data
            const allDbs = await getAllDatabaseNames();
            let totalRecovered = 0;
            
            for (const sourceDb of allDbs) {
                if (!sourceDb.includes('ETH_') && !sourceDb.includes('BASE_')) {
                    // This is a legacy database
                    const targetDb = 'ETH_' + sourceDb.replace('DB_', 'DB_').replace('DB-', 'DB_');
                    
                    log(`Attempting to recover ${sourceDb} ‚Üí ${targetDb}`, 'info');
                    
                    const source = await openDatabase(sourceDb);
                    const target = await openDatabase(targetDb);
                    
                    if (source && target) {
                        for (const storeName of source.objectStoreNames) {
                            if (target.objectStoreNames.contains(storeName)) {
                                const sourceCount = await getStoreCount(source, storeName);
                                const targetCount = await getStoreCount(target, storeName);
                                
                                if (sourceCount > 0 && targetCount === 0) {
                                    log(`Copying ${sourceCount} records from ${sourceDb}.${storeName}`, 'info');
                                    // Copy data
                                    const copied = await copyStoreData(source, target, storeName);
                                    totalRecovered += copied;
                                    log(`Copied ${copied} records`, 'success');
                                }
                            }
                        }
                        
                        source.close();
                        target.close();
                    }
                }
            }
            
            log(`Recovery complete. Recovered ${totalRecovered} total records`, totalRecovered > 0 ? 'success' : 'warning');
            await runFullDiagnostics();
        };
        
        async function copyStoreData(sourceDb, targetDb, storeName) {
            return new Promise((resolve) => {
                const sourceTransaction = sourceDb.transaction(storeName, 'readonly');
                const sourceStore = sourceTransaction.objectStore(storeName);
                const request = sourceStore.getAll();
                
                request.onsuccess = (event) => {
                    const data = event.target.result;
                    if (!data || data.length === 0) {
                        resolve(0);
                        return;
                    }
                    
                    const targetTransaction = targetDb.transaction(storeName, 'readwrite');
                    const targetStore = targetTransaction.objectStore(storeName);
                    
                    let copied = 0;
                    for (const item of data) {
                        try {
                            targetStore.put(item);
                            copied++;
                        } catch (e) {
                            console.error('Failed to copy item:', e);
                        }
                    }
                    
                    targetTransaction.oncomplete = () => resolve(copied);
                    targetTransaction.onerror = () => resolve(0);
                };
                
                request.onerror = () => resolve(0);
            });
        }
        
        window.exportAllData = async function() {
            log('Exporting all database data...', 'info');
            
            const exportData = {
                timestamp: new Date().toISOString(),
                databases: {}
            };
            
            const allDbs = await getAllDatabaseNames();
            
            for (const dbName of allDbs) {
                const db = await openDatabase(dbName);
                if (db) {
                    exportData.databases[dbName] = {
                        version: db.version,
                        stores: {}
                    };
                    
                    for (const storeName of db.objectStoreNames) {
                        const transaction = db.transaction(storeName, 'readonly');
                        const store = transaction.objectStore(storeName);
                        const data = await new Promise((resolve) => {
                            const request = store.getAll();
                            request.onsuccess = () => resolve(request.result || []);
                            request.onerror = () => resolve([]);
                        });
                        
                        exportData.databases[dbName].stores[storeName] = data;
                        log(`Exported ${data.length} records from ${dbName}.${storeName}`, 'info');
                    }
                    
                    db.close();
                }
            }
            
            // Download as JSON file
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `database_export_${Date.now()}.json`;
            a.click();
            
            log('Export complete! File downloaded.', 'success');
        };
        
        window.handleImportFile = async function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            log('Importing data from file...', 'info');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    for (const [dbName, dbData] of Object.entries(importData.databases)) {
                        log(`Importing ${dbName}...`, 'info');
                        
                        // Open or create database
                        const db = await openOrCreateDatabase(dbName, dbData.version, Object.keys(dbData.stores));
                        
                        for (const [storeName, storeData] of Object.entries(dbData.stores)) {
                            const transaction = db.transaction(storeName, 'readwrite');
                            const store = transaction.objectStore(storeName);
                            
                            for (const item of storeData) {
                                store.put(item);
                            }
                            
                            log(`Imported ${storeData.length} records to ${dbName}.${storeName}`, 'success');
                        }
                        
                        db.close();
                    }
                    
                    log('Import complete!', 'success');
                    await runFullDiagnostics();
                    
                } catch (error) {
                    log('Import failed: ' + error.message, 'error');
                }
            };
            
            reader.readAsText(file);
        };
        
        async function openOrCreateDatabase(name, version, storeNames) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(name, version);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    for (const storeName of storeNames) {
                        if (!db.objectStoreNames.contains(storeName)) {
                            let keyPath = 'id';
                            if (storeName === 'mints') keyPath = 'ID';
                            if (storeName === 'scanState') keyPath = 'address';
                            if (storeName === 'actionsCache') keyPath = 'address';
                            
                            db.createObjectStore(storeName, { keyPath });
                        }
                    }
                };
                
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        window.restoreBackup = async function(backupKey) {
            if (!confirm('This will restore from backup. Continue?')) return;
            
            log(`Restoring from backup ${backupKey}...`, 'info');
            
            try {
                const success = await superSafeMigrator.restoreFromBackup(backupKey);
                if (success) {
                    log('Backup restored successfully!', 'success');
                } else {
                    log('Backup restoration failed', 'error');
                }
                await runFullDiagnostics();
            } catch (error) {
                log('Restore error: ' + error.message, 'error');
            }
        };
        
        window.mergeDatabases = async function() {
            log('Checking for duplicate databases to merge...', 'info');
            
            // Check for similar databases
            const pairs = [
                ['DB_XenStake'],
                ['DB_XenftStake']
            ];
            
            for (const [db1, db2] of pairs) {
                if (await databaseExists(db1) && await databaseExists(db2)) {
                    log(`Found duplicates: ${db1} and ${db2}`, 'warning');
                    // Merge logic here if needed
                }
            }
            
            log('Merge check complete', 'info');
        };
        
        // Initialize on load
        updateStats();
        log('Recovery tool ready. Click "Run Full Diagnostics" to start.', 'info');
    </script>
</body>
</html>